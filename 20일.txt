그래프
: 데이터 간 관계를 표현한 자료구조 

상호배타 집합(disjoint-set)
-서로소 집합마다 그룹을 구분하기 위한 대표 요소가 1개씩 존재(어떻게 뽑을 것인가) : union(x, y), rank이용
-서로소 집합에 속한 요소가 각 집합의 대표 요소를 가리키고 있음(내(x)가 속한 그룹의 대표를 어떻게 찾을지): find-set(x)
-make-set(x) : 유일한 멤버 x를 포함하는 새로운 집합을 생성하는 연산 
-find-set(x) : x를 포함하는 집합을 찾는 작업(특정 노드에서 루트까지의 경로를 찾아 가면서 노드의 부모 정보를 갱신)
-union(x, y) : x와 y를 포함하는 두 집합을 통합하는 오퍼레이션
-> make-set()-> union()-> find-set()
-disjoint-set을 만들기 위해 union-find알고리즘을 사용
상호배타 집합의 표현 : 연결리스트(대표자-노드의 값-다음요소) / 트리(자식 노드가 부모 노드를 가리킨다. 조상 노드가 대표임)
-rank를 이용한 union : 각 노드는 자신을 루트로 하는 subtree의 높이를 rank로 갖는다. / 두 집합을 합칠 때 rank가 낮은 집합을 높은 집합에 붙인다.

-경로 압축 :  find-set()에서 만나는 모든 노드들이 직접 root를 가리키도록 포인터를 바꾸어준다. 
=> 트리의 높이를 줄이는 과정


<21일>
탐욕 기법으로 그래프에서 최소신장트리 찾기

그래프에서 최소 비용 문제
1. 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
2. 두 정점 사이의 최소 비용의 경로 찾기

※신장트리란?
:모든 정점이 연결되어 있고 사이클이 존재하지 않는 부분 그래프(= 간선의 개수가 N-1개)
한 그래프에서 여러 개의 신장 트리가 나올 수 있다. 

최소 신장 트리(Minimum Spanning Tree)
: 무방향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장 트리
ex) 전체 노드가 연결되면서 비용이 가장 적게 드는 경우의 수를 구하여라.
어떻게 구할 것인가? 
1) Prim Algorithm : 어느 한 정점을 기준으로 갈 수 있는 곳들 중 최소의 비용이 드는 곳을 고른다(단, 모든 정점을 방문할 때까지)
: 임의 정점을 하나 선택 -> 인접 정점 중 최소비용의 간선(정점)을 선택 -> 모든 정점이 선택될 때까지 앞의 과정을 반복
??? 모든 정점이 선택되었는지 어떤 방식으로 확인할 것인가? 서로소 집합이용
2) Kruskal Algorithm : 전체 간선 중에서 가중치가 작은 곳부터 선택한다 : 모든 간선을 정렬하는 작업이 필요함(우선순위 큐를 이용 or li.sort())

최단경로
: 간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중에 간선의 가중치의 합이 최소인 경로
-하나의 시작 정점에서 끝 정점까지의 최단경로 : dijkstra, Bellman-Ford
-모든 정점들에 대한 최단 경로: Floyd-Warshall

dijkstra algorithm
: 시작 정점에서 거리가 최소가 되도록 다음 정점을 선택해 나가면서 최단경로를 구하는 방식
prim알고리즘은 현재 정점 기준으로 인접한 정점까지의 간선 가중치 값만 고려하는데 비해, 다익스트라는 누적 거리를 최소화하는 정점을 선택한다. 
-특정 지점에서 도착 거리까지의 최단 거리를 구하여라 -> dijkstra
-가중치에 음수가 포함되어 있는 경우 -> Bellman-Ford
-다수의 지점에서 다수의 지점까지의 최단 거리를 구하여라 -> Floyd-Warshall