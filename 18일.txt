알고리즘 설계기법
1.완전탐색
배열 
그래프
2.탐욕법
3.DP
점화식(bottom-up) or 재귀(top-down)
4.분할정복
5.백트래킹

Merge Sort
분할 : 전체 자료집합을 최소 크기의 부분집합이 될 때까지 분할 작업을 계속한다.
-분할 작업 반복시 구조가 변하지 않음 -> 재귀로 구현 가능(하나의 부분집합을 또 다른 2개의 부분집합으로 분할하는 작업)
병합 : 부분집합을 2개씩 정렬하면서 하나의 집합으로 병합

Quick Sort
-분할할 때 기준 아이템(pivot item) 중심으로 이보다 작은 것은 왼편, 큰 것은 오른쪽에 위치시킨다.
-> pivot선택은 왼쪽 끝, 오른쪽 끝, 중간에 있는 값 중 median을 선택하는 경우가 일반적이다. 
-그런 다음 pivot을 두 집합의 가운데에 위치시킨다.
1.Hoare partition : 두 인덱스를 각각 왼쪽 끝과 오른쪽 끝에 위치시킨다. 
하나의 인덱스는 pivot보다 작은 값을, 나머지 인덱스는 pivot보다 큰 값을 찾아가며 두 인덱스 모두 해당하는 값을 찾은 경우 두 값의 위치를 swap한다.
두 인덱스가 교차하는 순간 하나의 cycle이 종료된다.(두 인덱스가 교차하는 위치는 pivot보다 작은값들과 큰값들을 나누는 경계가 된다.)
-> 이 cycle이 종료되고 pivot을 그보다 작은값과 큰 값의 경계에 위치시키고, 
pivot을 기준으로 분할된 두 개의 집합 각각에 대해 퀵정렬을 실시한다.(여기서 재귀로 구현)
2.Lomuto partition : 오른쪽 끝값을 pivot으로 설정, 두 인덱스 모두 왼쪽끝에서 출발하되, 만나는 값이 pivot보다 크면 큰 값을 찾는 인덱스는 그대로 두고, 작은값을 찾는 인덱스만 오른쪽으로 한 칸 이동시킨다.
두 인덱스 모두 조건을 만족하는 값을 찾았을 때, 작은 값을 찾은 인덱스의 값과 큰 값을 찾은 인덱스의 바로 오른쪽에 위치한 값을 swap한다.
-> 큰값을 찾는 인덱스가 pivot의 바로 왼쪽에 도착한 경우 하나의 cycle이 종료된다. -> 작은값을 찾는 인덱스의 바로 오른쪽값이 pivot을 위치시킬 경계가 된다.
※pivot보다 작거나 같은 값을 찾으면 swap이 일어나므로, 동일한 값이 많은 배열을 정렬하는 경우 효율이 떨어진다. 

이진 검색(Binary Search)
전제조건 : 자료를 정렬해놓고 검색 시작
